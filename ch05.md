第五章程式碼：
<a href="https://colab.research.google.com/github/ytlLab/PYTHON/blob/main/ch05.ipynb" target="_blank">
  <img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab">
</a>

# 集合

Python可以使用大括號”{ }”或set( )函數建立集合
例如：如果集合名稱是langs，內容是’Python’ 、’C’ 、’Java’。可以使用下列方式設定集合。

```
#練習 基本集合的建立

langs = {'Python', 'C', 'Java'}
print("列印集合 = ", langs)
print("列印類別 = ", type(langs))
```

```
#練習 基本集合的建立，建立時部分元素重複

langs = {'Python', 'C', 'Java', 'Python', 'C'}
print(langs)
```

```
#練習 使用整數和不同資料型態所建的集合

# 集合由整數所組成
integer_set = {1, 2, 3, 4, 5}
print(integer_set)
# 集合由不同資料型態所組成
mixed_set = {1, 'Python', (2, 5, 10)}
print(mixed_set)
# 集合的元素是不可變的所以程式第6行所設定的元組元素改成
# 第10行串列的寫法將會產生錯誤
# mixed_set = { 1, 'Python', [2, 5, 10]}
```

```
#練習 建立空集合並觀察執行結果，錯誤的實例

x = {}                  	# 這是建立空字典非空集合
print("列印 	= ", x)
print("列印類別 = ", type(x))
```

使用set( )函數定義集合
set( )函數參數的內容可以是字串(string)、串列(list)、元組(tuple)、字典(dict) … 等

```
#練習 使用set( )函數建立空集合。

empty_dict = {}                  	# 這是建立空字典
print("列印類別 = ", type(empty_dict))
empty_set = set()                	# 這是建立空集合
print("列印類別 = ", type(empty_set))
```

```
#練習 使用字串(string)建立與列印集合，同時列出集合的資料型態

x = set('DeepStone mean Deep Learning')
print(x)
print(type(x))
```

```
#練習 使用串列(list)建立與列印集合

# 表達方式1
fruits = ['apple', 'orange', 'apple', 'banana', 'orange']
x = set(fruits)
print(x)
# 表達方式2
y = set(['apple', 'orange', 'apple', 'banana', 'orange'])
print(y)
```

```
#練習 使用元組(tuple)建立與列印集合

cities = set(('Beijing', 'Tokyo', 'Beijing', 'Taipei', 'Tokyo'))
print(cities)
```

```
#練習 使用字典建立集合時，字典的鍵會被當作集合的元素，這個程式會列印集合

asia = {'China':'Beijing', 'Japan':'Tokyo', 'Thailand':'Bangkok'}
asiaSet = set(asia)
print(asiaSet)
```

```
#練習 將串列內重複性的資料刪除

fruits1 = ['apple', 'orange', 'apple', 'banana', 'orange']
x = set(fruits1)            	# 將串列轉成集合
fruits2 = list(x)           	# 將集合轉成串列
print("原先串列資料fruits1 = ", fruits1)
print("新的串列資料fruits2 = ", fruits2)
```

<img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/0be07220-7253-42f7-aa7a-e44f7c93a4c7" />

## 交集(intersection)
```
#練習

math = {'Kevin', 'Peter', 'Eric'}   	# 設定參加數學夏令營成員
physics = {'Peter', 'Nelson', 'Tom'}	# 設定參加物理夏令營成員
both = math & physics
print("同時參加數學與物理夏令營的成員 ",both)
```

```
#練習 使用intersection( )方法

A = {1, 2, 3, 4, 5}     	# 定義集合A
B = {3, 4, 5, 6, 7}     	# 定義集合B
# 將intersection( )應用在A集合
AB = A.intersection(B)  	# A和B的交集
print("A和B的交集是 ", AB)
# 將intersection( )應用在B集合
BA = B.intersection(A)  	# B和A的交集
print("B和A的交集是 ", BA)
```

## 聯集(union)
```
#練習

math = {'Kevin', 'Peter', 'Eric'}   	# 設定參加數學夏令營成員
physics = {'Peter', 'Nelson', 'Tom'}	# 設定參加物理夏令營成員
allmember = math | physics
print("同時參加數學與物理夏令營的成員 ",allmember)
```

```
#練習 使用union( )方法

A = {1, 2, 3, 4, 5}         	# 定義集合A
B = {3, 4, 5, 6, 7}         	# 定義集合B
# 將union( )應用在A集合
AorB = A.union(B)           	# A和B的聯集
print("A和B的聯集是 ", AorB)    
# 將union( )應用在B集合
BorA = B.union(A)           	# B和A的聯集
print("B和A的聯集是 ", BorA)
```

## 差集(difference)
```
#練習

math = {'Kevin', 'Peter', 'Eric'}   	# 設定參加數學夏令營成員
physics = {'Peter', 'Nelson', 'Tom'}	# 設定參加物理夏令營成員
math_only = math - physics
print("參加數學夏令營同時沒有參加物理夏令營的成員 ",math_only)
physics_only = physics - math
print("參加數學夏令營同時沒有參加物理夏令營的成員 ",physics_only)
```

```
#練習 使difference( )方法

A = {1, 2, 3, 4, 5}         	# 定義集合A
B = {3, 4, 5, 6, 7}         	# 定義集合B
# 將difference( )應用在A集合
A_B = A.difference(B)       	# A-B的差集
print("A-B的差集是 ", A_B)    
# 將difference( )應用在B集合
B_A = B.difference(A)       	# B-A的差集
print("B-A的差集是 ", B_A)
```

## 對稱差集(symmetric difference)

有A和B兩個集合，如果想獲得屬於A或是B集合元素，但是排除同時屬於A和B的元素。
<img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/899665d6-2044-4750-ab55-b56dc09209a0" />

```
#練習

math = {'Kevin', 'Peter', 'Eric'}   	# 設定參加數學夏令營成員
physics = {'Peter', 'Nelson', 'Tom'}	# 設定參加物理夏令營成員
math_sydi_physics = math ^ physics
print("沒有同時參加數學和物理夏令營的成員 ",math_sydi_physics)
```

```
#練習 使用symmetric_difference( )方法

A = {1, 2, 3, 4, 5}                 	# 定義集合A
B = {3, 4, 5, 6, 7}                 	# 定義集合B
# 將symmetric_difference( )應用在A集合
A_sydi_B = A.symmetric_difference(B)	# A和B的對稱差集
print("A和B的對稱差集是 ", A_sydi_B)    
# 將symmetric_difference( )應用在B集合
B_sydi_A = B.symmetric_difference(A)	# B和A的對稱差集
print("B和A的對稱差集是 ", B_sydi_A)
```

等於的Python符號是”==”，可以獲得2個集合是否相等，如果相等傳回True，否則傳回False。
```
#練習

A = {1, 2, 3, 4, 5}                 	# 定義集合A
B = {3, 4, 5, 6, 7}                 	# 定義集合B
C = {1, 2, 3, 4, 5}                 	# 定義集合C
# 列出A與B集合是否相等                         	 
print("A與B集合相等", A == B)
# 列出A與C集合是否相等                        	 
print("A與C集合相等", A == C)
```

不等於的Python符號是”!=”，可以獲得2個集合是否不相等，如果不相等傳回True，否則傳回False。
```
#練習

A = {1, 2, 3, 4, 5}                 	# 定義集合A
B = {3, 4, 5, 6, 7}                 	# 定義集合B
C = {1, 2, 3, 4, 5}                 	# 定義集合C
# 列出A與B集合是否相等                        	 
print("A與B集合不相等", A != B)
# 列出A與C集合是否不相等                         	 
print("A與C集合不相等", A != C)  
```

Python的關鍵字in可以測試元素是否是集合的元素成員

```
#練習

# 方法1
fruits = set("orange")
print("字元a是屬於fruits集合?", 'a' in fruits)
print("字元d是屬於fruits集合?", 'd' in fruits)
# 方法2
cars = {"Nissan", "Toyota", "Ford"}
boolean = "Ford" in cars
print("Ford in cars", boolean)
boolean = "Audi" in cars
print("Audi in cars", boolean)
```

```
#練習 使用迴圈列出所有參加數學夏令營的學生

math = {'Kevin', 'Peter', 'Eric'}   	# 設定參加數學夏令營成員
print("列印參加數學夏令營的成員")
for name in math:
	print(name)
```

Python的關鍵字not in可以測試元素是否不是集合的元素成員
```
#練習

# 方法1
fruits = set("orange")
print("字元a是不屬於fruits集合?", 'a' not in fruits)
print("字元d是不屬於fruits集合?", 'd' not in fruits)
# 方法2
cars = {"Nissan", "Toyota", "Ford"}
boolean = "Ford" not in cars
print("Ford not in cars", boolean)
boolean = "Audi" not in cars
print("Audi not in cars", boolean)
```
## 作業

請建立兩個串列

A: 1,3,5,⋯,99

B: 5,10,15,⋯,100

將上述轉為集合，求出交集、聯集、A-B差集、B-A差集、對稱差集

## 適用集合的方法
<img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/b9b27142-fb08-43bb-9460-74f64d9cb73b" />

### add()

add( )可以增加一個元素，它的語法格式如下：

集合A.add(新增元素)
```
#練習

cities = { 'Taipei', 'Beijing', 'Tokyo'}
# 增加一般元素
cities.add('Chicago')
print('cities集合內容 ', cities)
# 增加已有元素並觀察執行結果
cities.add('Beijing')
print('cities集合內容 ', cities)
# 增加元組元素並觀察執行結果
tup = (1, 2, 3)
cities.add(tup)
print('cities集合內容 ', cities)
```

### copy( )
新集合名稱 = 舊集合名稱.copy( )
```
#練習

# 賦值
numset = {1, 2, 3}
deep_numset = numset
deep_numset.add(10)
print("賦值   - 觀察numset    	", numset)
print("賦值   - 觀察deep_numset   ", deep_numset)
# 淺拷貝shallow copy
shallow_numset = numset.copy( )
shallow_numset.add(100)
print("淺拷貝 - 觀察numset    	", numset)
print("淺拷貝 - 觀察shallow_numset", shallow_numset)
```

### remove( )

集合A.remove(欲刪除的元素)

```
#練習 使用remove( )刪除集合元素成功

countries = {'Japan', 'China', 'France'}
print("刪除前的countries集合 ", countries)
countries.remove('Japan')
print("刪除後的countries集合 ", countries)
```

```
#練習 使用remove( )刪除集合元素失敗

animals = {'dog', 'cat', 'bird'}
print("刪除前的animals集合 ", animals)
animals.remove('fish')    	# 刪除不存在的元素產生錯誤
print("刪除後的animals集合 ", animals)
```

### discard( )
ret_value = 集合A.discard(欲刪除的元素)

```
#練習 使用discard( )刪除集合元素
animals = {'dog', 'cat', 'bird'}
print("刪除前的animals集合	", animals)
# 欲刪除元素有在集合內
animals.discard('cat')   	 
print("刪除後的animals集合	", animals)
# 欲刪除元素沒有在集合內
animals.discard('pig')
print("刪除後的animals集合	", animals)
# 列印傳回值
print("刪除資料存在的傳回值   ", animals.discard('dog'))
print("刪除資料不存在的傳回值 ", animals.discard('pig'))
```

### pop( )
ret_element = 集合A.pop( )

```
#練習 使用pop( )刪除集合元素

animals = {'dog', 'cat', 'bird'}
print("刪除前的animals集合 ", animals)
ret_element = animals.pop( )   	 
print("刪除後的animals集合 ", animals)
print("所刪除的元素是  	", ret_element)
```

### clear( )
clear( )可以刪除集合內的所有元素，傳回值是None

```
#練習

states = {'Mississippi', 'Idoho', 'Florida'}
print("刪除前的states集合	", states)
states.clear( )
print("刪除前的states集合	", states)

# 測試刪除空集合
empty_set = set( )
print("刪除前的empty_set集合 ", empty_set)
states.clear( )
print("刪除前的empty_set集合 ", empty_set)
```

### isdisjoint( )
如果2個集合沒有共同的元素會傳回True，否則傳回False。

ret_boolean = 集合A.isdisjoint(集合B)

```
#練習 isdisjoint( )

A = {'a', 'b', 'c'}
B = {'c', 'd', 'e'}
C = {'h', 'k', 'p'}
# 測試A和B集合
boolean = A.isdisjoint(B)   	# 有共同的元素'c'
print("有共同的元素傳回值是   ", boolean)
# 測試A和C集合
boolean = A.isdisjoint(C)   	# 沒有共同的元素
print("沒有共同的元素傳回值是 ", boolean)
```

### issubset( )
這個方法可以測試一個函數是否是另一個函數的子集合，

例如，A集合所有元素均可在B集合內發現，則A集合是B集合的子集合。

```
#練習issubset( )

A = {'a', 'b', 'c'}
B = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'k'}
C = {'k', 'm', 'n'}
# 測試A和B集合
boolean = A.issubset(B)     	# 所有A的元素皆是B的元素
print("A集合是B集合的子集合傳回值是 ", boolean)
# 測試C和B集合
boolean = C.issubset(B)     	# 有共同的元素k
print("C集合是B集合的子集合傳回值是 ", boolean)
```

### intersection_update( )
ret_value = A.intersection_update(*B)

#不同於 intersection() 方法，因為 intersection() 方法是返回一个新的集合，

而 intersection_update() 方法是在原始的集合上移除不重叠的元素。

```
#練習intersection_update( )

A = {'a', 'b', 'c', 'd'}
B = {'a', 'k', 'c'}
C = {'c', 'f', 'w'}
# A將是A和B的交集
ret_value = A.intersection_update(B)
print(ret_value)
print("A集合 = ", A)
print("B集合 = ", B)
# A將是A, B和C的交集
ret_value = A.intersection_update(B, C)
print(ret_value)
print("A集合 = ", A)
print("B集合 = ", B)
print("C集合 = ", C)
```

### update( )
集合A.update(集合B)

```
#練習 update( )

cars1 = {'Audi', 'Ford', 'Toyota'}
cars2 = {'Nissan', 'Toyota'}
print("執行update( )前列出cars1和cars2內容")
print("cars1 = ", cars1)
print("cars2 = ", cars2)
cars1.update(cars2)
print("執行update( )後列出cars1和cars2內容")
print("cars1 = ", cars1)
print("cars2 = ", cars2)
```

### symmetric_difference_update( )
集合A.symmetric_difference_update(集合B)

```
#練習symmetric_difference_update( )

cars1 = {'Audi', 'Ford', 'Toyota'}
cars2 = {'Nissan', 'Toyota'}
print("執行difference_update( )前列出cars1和cars2內容")
print("cars1 = ", cars1)
print("cars2 = ", cars2)
cars1.difference_update(cars2)
print("執行difference_update( )後列出cars1和cars2內容")
print("cars1 = ", cars1)
print("cars2 = ", cars2)
```

## 適用集合的基本函數操作
<img width="600" height="300" alt="image" src="https://github.com/user-attachments/assets/b1e5db22-c496-4ddb-b611-7ec99bd7f6ba" />

### 凍結集合frozenset
set是可變集合，frozenset是不可變集合也可直譯為凍結集合，這是一個新的類別(class)，

只要設定元素後，這個凍結集合就不能再更改了。如果將元組(tuple)想成不可變串列(immutable list)，

凍結集合就是不可變集合(immutable set)。

```
#練習 凍結集合frozenset

X = frozenset([1, 3, 5])
Y = frozenset([5, 7, 9])
print(X)
print(Y)
print("交集  = ", X & Y)
print("聯集  = ", X | Y)
A = X & Y
print("交集A = ", A)
A = X.intersection(Y)
print("交集A = ", A)
```

### 集合生成式
新集合 = { 運算式  for  運算式  in  可迭代項目 }

```
#練習 產生1,3, …, 99的集合

A = {n for n in range(1,100,2)}
print(type(A))
print(A)
```

# 元組(tuple)
Python提供另一種資料型態稱元組(tuple)，這種資料型態結構與串列完全相同，

元組與串列最大的差異是，它的元素值與元素個數不可更動，有時又可稱不可改變的串列。

## 元組的功能
可以更安全的保護資料

增加程式執行速度

## 元組的定義
name_tuple = (元素1, … , 元素n,)   # name_tuple是假設的元組名稱

如果元組內的元素只有一個，在定義時需在元素右邊加上逗號(“,”)。

name_tuple = (元素1,)   	    	# 只有一個元素的元組

```
#練習

numbers1 = (1, 2, 3, 4, 5)  	# 定義元組元素是整數
fruits = ('apple', 'orange')	# 定義元組元素是字串
mixed = ('James', 50)       	# 定義元組元素是不同型態資料
val_tuple = (10,)           	# 只有一個元素的元祖
print(numbers1)
print(fruits)
print(mixed)
print(val_tuple)
# 列出元組資料型態
print("元組mixed資料型態是: ",type(mixed))
```

```
#練習 修改元組內容產生錯誤的實例

fruits = ('apple', 'orange')    	# 定義元組元素是字串
print(fruits[0])                	# 列印元組fruits[0]
fruits[0] = 'watermelon'        	# 將元素內容改為watermelon
print(fruits[0])                	# 列印元組fruits[0]
```

```
#練習 全新定義方式修改元組元素

fruits = ('apple', 'orange')    	# 定義元組元素是水果
print("原始fruits元組元素")
for fruit in fruits:
	print(fruit)
fruits = ('watermelon', 'grape')	# 定義新的元組元素
print("\n新的fruits元組元素")
for fruit in fruits:
	print(fruit)
```

```
#練習 元組切片的應用

fruits = ('apple', 'orange', 'banana', 'watermelon', 'grape')
print(fruits[1:3])
print(fruits[:2])
print(fruits[1:])
print(fruits[-2:])
print(fruits[0:5:2])
```

## 方法與函數
```
#練習 列出元組元素長度(個數)

keys = ('magic', 'xaab', 9099)  	# 定義元組元素是字串與數字
print("keys元組長度是 %d " % len(keys))
```
```
#練習 用會減少元組元素的方法pop( )，產生錯誤

keys = ('magic', 'xaab', 9099)  	# 定義元組元素是字串與數字
key = keys.pop( )       	# 錯誤
```
```
#練習 用會增加元組元素的方法append( )，產生錯誤

keys = ('magic', 'xaab', 9099)  	# 定義元組元素是字串與數字
keys.append('secret')       	# 錯誤
```

串列與元組資料互換

```
#練習 list(元組)：將元組資料型態改為串列

keys = ('magic', 'xaab', 9099)  	# 定義元組元素是字串與數字
list_keys = list(keys)          	# 將元組改為串列
list_keys.append('secret')      	# 增加元素
print("列印元組", keys)
print("列印串列", list_keys)
```

```
#練習 tuple(串列)：將串列資料型態改為元組

keys = ['magic', 'xaab', 9099]  	# 定義串列元素是字串與數字
tuple_keys = tuple(keys)        	# 將串列改為元組
print("列印串列", keys)
print("列印元組", tuple_keys)
tuple_keys.append('secret')     	# 增加元素 --- 錯誤錯誤
```
## 作業
定義一個元組有重複的元素 tp=(1,2,3,4,5,2,3,1,4)，

請建立一個新的newtp，此新元組儲存相同但沒有重複的元素。

提示：使用串列處理，最後轉成元組。

